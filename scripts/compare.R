#!/usr/bin/env Rscript

# Author: jhyao
# Date: Dec 15, 2024
# Description:
# This script compares pseudotime-based gene expression differences across 
# various single-cell datasets using permutation-based significance testing. 
# It leverages result directories containing original and shuffled datasets 
# generated by Cyclum and computes p-values to identify significantly dynamic genes.

library(argparse)

# Automatically determine the directory of the current script
args_full <- commandArgs(trailingOnly = FALSE)
script_path <- sub("--file=", "", args_full[grep("--file=", args_full)])
if (!length(script_path)) {
  # If Rscript did not provide --file, attempt an alternative method
  script_path <- sys.frames()[[1]]$ofile
}
r_script_path <- dirname(normalizePath(script_path))

# Source auxiliary scripts from the script's directory
source(file.path(r_script_path, "gsea.R"))
source(file.path(r_script_path, "hdfrw.R"))

# Function to load data from an HDF5 file, including matrix, row names, and column names
hdf2mat <- function(filepath) {
  library(rhdf5)
  f <- H5File$new(filepath, mode = "r")
  if (f$exists('matrix')) {
    mat <- f[['matrix']]$read()
    if (is.vector(mat)) {
      mat <- as.data.frame(matrix(mat, nrow = 1, ncol = length(mat)))
    } else if (is.matrix(mat)) {
      mat <- as.data.frame(mat)
    }
  } else {
    h5close(f)
    stop("No 'matrix' dataset found in the file.")
  }
  if (f$exists('colnames')) {
    colnames(mat) <- f[['colnames']]$read()
  }
  if (f$exists('rownames')) {
    rownames(mat) <- f[['rownames']]$read()
  }
  h5close(f)
  return(mat)
}

# Function to load and prepare weights and pseudotime data from the specified directory
load_and_process <- function(directory) {
  weight_file <- file.path(directory, "weights.h5")
  pseudotime_file <- file.path(directory, "pseudotime.h5")
  list(weight = hdf2mat(weight_file), pseudotime = hdf2mat(pseudotime_file))
}

# Performs permutation-based comparison with directionality using the provided original and shuffled datasets
perform_comparison_with_permutation <- function(original_data1, original_data2, shuffled_data_list1, shuffled_data_list2, genes, output_dir) {
  # Determine the minimum number of available shuffled datasets
  n1 <- length(shuffled_data_list1)
  n2 <- length(shuffled_data_list2)
  
  original_weight1 <- original_data1$weight[genes, , drop = FALSE]
  original_weight2 <- original_data2$weight[genes, , drop = FALSE]
  
  # Compute magnitudes while retaining directional differences
  mag1 <- abs(original_weight1[, 1] + 1i * original_weight1[, 2])
  mag2 <- abs(original_weight2[, 1] + 1i * original_weight2[, 2])
  mag_diff <- mag1 - mag2  # Directional differences are preserved in magnitude differences
  
  # Initialize arrays to store permuted differences for each gene
  perm_diffs <- vector("list", length(genes))
  for (i in 1:length(genes)) {
    perm_diffs[[i]] <- numeric(n1 * n2)
  }
  
  # Compute differences for all pairs of shuffled datasets to build null distributions
  for (j in 1:n1) {
    shuffled_weight1 <- shuffled_data_list1[[j]]$weight[genes, , drop = FALSE]
    shuffled_mag1 <- abs(shuffled_weight1[, 1] + 1i * shuffled_weight1[, 2])
    
    for (k in 1:n2) {
      shuffled_weight2 <- shuffled_data_list2[[k]]$weight[genes, , drop = FALSE]
      shuffled_mag2 <- abs(shuffled_weight2[, 1] + 1i * shuffled_weight2[, 2])
      
      shuffled_diff <- shuffled_mag1 - shuffled_mag2
      index <- (j - 1) * n2 + k
      for (i in 1:length(genes)) {
        perm_diffs[[i]][index] <- shuffled_diff[i]
      }
    }
  }
  
  # Calculate p-values for each gene based on the permutation null models
  p_values <- sapply(1:length(genes), function(i) {
    mean(abs(perm_diffs[[i]]) >= abs(mag_diff[i]))
  })
  
  adjusted_p_values <- p.adjust(p_values, method = "fdr")
  significant_genes <- adjusted_p_values < 0.05
  
  results_df <- data.frame(
    Gene = genes,
    Magnitude_Difference = mag_diff,
    P_Value = p_values,
    Adjusted_P_Value = adjusted_p_values,
    Significant = significant_genes
  )
  
  # Ensure the output directory exists and save the results
  dir.create(output_dir, recursive = TRUE, showWarnings = FALSE)
  
  write.csv(results_df, file.path(output_dir, "permutation_significance_results_with_direction.csv"), row.names = FALSE)
  saveRDS(results_df, file.path(output_dir, "permutation_test_results_with_direction.rds"))
  
  return(list(significant_genes = significant_genes, p_values = p_values, adjusted_p_values = adjusted_p_values))
}

# Conducts a comparison between two directories containing original and shuffled pseudotime data, storing results in main_path
perform_comparison <- function(dir1, dir2, genes, main_path) {
  dir1_name <- basename(dir1)
  dir2_name <- basename(dir2)
  analysis_dir_name <- paste0(dir1_name, "_vs_", dir2_name)
  analysis_path <- file.path(main_path, analysis_dir_name)
  dir.create(analysis_path, recursive = TRUE, showWarnings = FALSE)
  
  # Load original and shuffled datasets from both directories
  original1 <- load_and_process(list.files(dir1, pattern = "original", full.names = TRUE)[1])
  original2 <- load_and_process(list.files(dir2, pattern = "original", full.names = TRUE)[1])
  shuffles1 <- lapply(list.files(dir1, pattern = "shuffle", full.names = TRUE), load_and_process)
  shuffles2 <- lapply(list.files(dir2, pattern = "shuffle", full.names = TRUE), load_and_process)
  
  # Perform permutation-based comparison
  comparison_results <- perform_comparison_with_permutation(original1, original2, shuffles1, shuffles2, genes, analysis_path)
  return(comparison_results)
}

# Reads a list of directory pairs and performs comparisons for all pairs
run_all_comparisons <- function(main_path, comparison_list_file) {
  # Read directory pairs from the specified file
  comparison_pairs <- read.table(comparison_list_file, header=FALSE, stringsAsFactors=FALSE)
  
  # Use the first directory pair to obtain the list of genes
  dir1 <- comparison_pairs[1,1]
  original1 <- load_and_process(list.files(dir1, pattern = "original", full.names = TRUE)[1])
  genes <- rownames(original1$weight)
  
  # Iterate through each pair and conduct comparisons
  for (i in 1:nrow(comparison_pairs)) {
    dir1 <- comparison_pairs[i, 1]
    dir2 <- comparison_pairs[i, 2]
    perform_comparison(dir1, dir2, genes, main_path)
  }
}

# Parse command-line arguments (utils_dir is no longer required)
parser <- ArgumentParser(description = "Conduct permutation-based comparative analyses with directionality on pseudotime-derived datasets.")
parser$add_argument("--comparison_list", required=TRUE, help="File path listing pairs of directories to compare.")
parser$add_argument("--output_dir", required=TRUE, help="Output base directory for all comparative analyses.")
args <- parser$parse_args()

main_path <- args$output_dir
dir.create(main_path, recursive = TRUE, showWarnings = FALSE)
run_all_comparisons(main_path, args$comparison_list)

